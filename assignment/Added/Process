Figuring out how to read the code was a multi-step process that required the use of various tools and techniques.

Steps:
1. Copy strings from function calls in to their own variables and replace the strings in the function calls with their respective variable names. This helps to shorten the code by separating the functional parts of the code from the static values.
2. Remove all whitespace from the functional code and turn the return statement in to one line. Doing this was so that there wouldn't be any confusing tabs or spaces to throw me off for following steps.
3. Use parenthesis to clearly and visually encapsulate the parts of the code and make it easier to see where parts of the code lie with respect to other parts. This step requires compiling multiple times to make sure each step retains the same logic and doesn't generate any errors. This step adds many redundant parenthesis around various parts of the code, but makes it clear where each part begins and ends.
4. Adding the whitespace to the code. This is to make the code look more readable and like traditional code with proper indenting. Whenever I would run in to the begining of a set of parenthesis, I would make a new line and add an indent. Whenever I came across the end of a set of parenthesis, I would reset the indent. After this I could remove the unneeded parenthesis.
5. Converting the ternary operators in to their keyword if-else counterparts. This step helped with the debugger recognizing each step in the code's algorithm. I would add a return to each expression I saw as necessary. The one thing that was slowing down my progress was the commas near the first part of the code:
t<3?main(-79,-13,a+main(-87,1-_,main(-86,0,a+1)+a)):1,t<_?main(t+1,_,a):3,main(-94,-27+t,a)&&t==2?_<13?main(2,_+1,"%s %d %d\n"):9:16
After a little research, though I figured out that the return statement only returns the value of the expression after the last comma. Anything before that is just to create side effects. Similar to having multiple lines in code where only the last line has a return statement. So I then structured the code based on that to just be an if statement with three independent if statements executing in order.
6. Read through the code and rename the variables according to what I thought their purpose was. This helped to make the code more readable so I could easily recognize what the code was doing and what was being changed or used based on the names. I also changed the way some of the logic was written so that it would be the same logic, but more straightforward about what it was doing. Changing things like if(!0<t) to if(1<t), since !0==1 in c, or even if(t>1) made it much easier to read for me.
7. Adding comments for what the logic was doing. Many of the if statements were executing only when t was within an expected range. I used comments to spell out what parts of the code to look at when t was being passed. This made the process of tracing the code much easier. I also left comments about what behaviors certain parts of the code would produce. Making it much easier to resolve what would happen under certain conditions in the code.
8. Run the code through a debugger. This was the final step. I used this after I had figured out most of the code and there were just a few things I was missing in my understanding of the code as well as to verify that I understood the code. I took the code step by step to see what would happen to the variables placing breakpoints at certain locations and repeatedly continuing to see what had updated. This helped me confirm how exactly the code was working and make sure my trace was correct.
